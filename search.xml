<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>对于格中SIS难题的学习记录</title>
      <link href="2021/04/06/dui-yu-ge-zhong-sis-nan-ti-de-xue-xi-ji-lu/"/>
      <url>2021/04/06/dui-yu-ge-zhong-sis-nan-ti-de-xue-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>很久之前就开始看格中的SIS难题了，但总是看了忘，因此想好好的记录一下，加深自己的学习成果，我学习格的主要参考来源于知乎上的一个大佬：<a href="https://www.zhihu.com/people/steven-yue-72/columns">Steven Yue</a>。</p><h2 id="初识SIS"><a href="#初识SIS" class="headerlink" title="初识SIS"></a>初识SIS</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>在讲SIS之前，我们需要先了解一下单向函数（OWF：one way function）。单向函数在密码学中有着极其重要的作用，比如哈希函数。因为是单向的，所以敌手无法根据函数值推算出变量值，从而实现安全的目的。</p><p>我们再了解一下q价随机格的生成方式为：</p><p><img src="https://www.zhihu.com/equation?tex=%5CLambda_q(%5Cmathbf%7BA%7D)+=+%5C%7B%5Cmathbf%7Bx%7D+:+%5Cmathbf%7Bx%7D+%5Ctext%7B+mod+%7D+q+%5Cin+%5Cmathbf%7BA%7D%5ET+%5Cmathbb%7BZ%7D%5E%7Bn%7D_q%5C%7D+%5Csubseteq+%5Cmathbb%7BZ%7D%5Ed+%5C%5C" alt="[公式]"></p><p>而其对应的对偶格为：</p><p><img src="https://www.zhihu.com/equation?tex=%5CLambda_q%5E%5Cperp(%5Cmathbf%7BA%7D)+=+%5C%7B%5Cmathbf%7Bx%7D:+%5Cmathbf%7BAx%7D+=+0+%5Ctext%7B+mod+%7D+q%5C%7D+%5Csubseteq+%5Cmathbb%7BZ%7D%5Ed+%5C%5C" alt="[公式]"></p><h3 id="SIS问题"><a href="#SIS问题" class="headerlink" title="SIS问题"></a>SIS问题</h3><p>SIS，全称为：Short Integer Solution（短整数解），它就是一个单向函数。这个OWF的构造是这样的：</p><p>​        首先，我们随机选取一个<img src="https://www.zhihu.com/equation?tex=n+%5Ctimes+m" alt="[公式]">阶的矩阵<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BA%7D+%5Cin+%5Cmathbb%7BZ%7D_q%5E%7Bn+%5Ctimes+m%7D" alt="[公式]">（即矩阵A中数字的上限为q），然后我们这个OWF的输入就是一个二进制向量<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bx%7D+%5Cin+%5C%7B0,1%5C%7D%5Em" alt="[公式]">。这个OWF的输出则是：</p><p><img src="https://www.zhihu.com/equation?tex=f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D)+=+%5Cmathbf%7BAx%7D+%5Ctext%7B+mod+%7D+q+%5C%5C" alt="[公式]"></p><p>图像表示如下：</p><p><img src="https://pic3.zhimg.com/80/v2-318f50fe2fc8774b21456f110509999e_1440w.jpg" alt="img"></p><p>也就是说，我们任意选择一个二进制的短向量，这个向量和随机矩阵的乘积就是OWF的输出了。这个OWF输出的值，其实就是<img src="https://www.zhihu.com/equation?tex=%5CLambda_q(%5Cmathbf%7BA%7D)" alt="[公式]">中的一个格点。有趣的是，我们可以根据对偶格的性质很容易的找到这个问题的一个碰撞：</p><p>只要能够找到一个短向量<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bv%7D+%5Cin+%5CLambda_q%5E%5Cperp" alt="[公式]">，已知向量<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bx%7D" alt="[公式]">以及OWF的结果<img src="https://www.zhihu.com/equation?tex=f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D)" alt="[公式]">，我们就可以找到这个OWF的一个collision：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign*%7D+f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx+++v%7D)+&=+%5Cmathbf%7BA%7D(%5Cmathbf%7Bx+++v%7D)%5C%5C+&=+%5Cmathbf%7BAx+++Av%7D+(%5Ctext%7Bmod+%7Dq)%5C%5C+&=+%5Cmathbf%7BAx%7D%5C+(%5Ctext%7Bmod+%7Dq)%5C%5C+&=+f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D)+%5Cend%7Balign*%7D+%5C%5C" alt="[公式]"></p><p>因此当我们把OWF的输入格式简化成一个向量<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bx%7D" alt="[公式]">加上对偶格中的某个格点<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bv%7D" alt="[公式]">之后，根据OWF的输出还原出<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bx%7D" alt="[公式]">就变成了一个CVP问题：问题给出的向量就是<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bt%7D+=+%5Cmathbf%7Bx%7D+++%5CLambda_q%5E%5Cperp(%5Cmathbf%7BA%7D)" alt="[公式]">，然后我们只要能够找到附近的格点<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bv%7D" alt="[公式]">，就可以相减算出<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bx%7D" alt="[公式]">了。不过因为有碰撞的存在，所以不一定是最近的那个格点，任何一个合适的格点都可以。</p><p>总结一下，一个SIS构成的OWF有以下一系列的参数：</p><ul><li>矩阵的维度和模组的大小：<img src="https://www.zhihu.com/equation?tex=m,+n,+q+%5Cin+%5Cmathbb%7BZ%7D" alt="[公式]">。</li><li>OWF的key：<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BA%7D+%5Cin+%5Cmathbb%7BZ%7D%5E%7Bn+%5Ctimes+m%7D_q" alt="[公式]">，即一个随机的<img src="https://www.zhihu.com/equation?tex=n+%5Ctimes+m" alt="[公式]">阶的矩阵。</li><li>OWF的输入：<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bx%7D+%5Cin+%5C%7B0,1%5C%7D%5Em" alt="[公式]">，即一个长度为<img src="https://www.zhihu.com/equation?tex=m" alt="[公式]">的二进制向量。这里要求二进制的原因是为了确保这个向量的长度足够的短（符合短向量的条件）。理论上也可以使用<img src="https://www.zhihu.com/equation?tex=O(1)" alt="[公式]">范围内任何区间。</li><li>OWF的输出：<img src="https://www.zhihu.com/equation?tex=f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D)+=+%5Cmathbf%7BAx%7D+%5Ctext%7B+mod+%7Dq" alt="[公式]">。</li></ul><p>​       只要矩阵的维度符合<img src="https://www.zhihu.com/equation?tex=m+%3E+n+%5Ccdot+log(q)" alt="[公式]">这一标准，并且SIVP问题困难的话，那么此<img src="https://www.zhihu.com/equation?tex=f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D)" alt="[公式]">就是一个合理的OWF。因为在这个条件下，SIS的反问题会被转化成lattice中的CVP难题。</p><h2 id="SIS的性能分析"><a href="#SIS的性能分析" class="headerlink" title="SIS的性能分析"></a>SIS的性能分析</h2><h3 id="SIS的抗碰撞证明"><a href="#SIS的抗碰撞证明" class="headerlink" title="SIS的抗碰撞证明"></a><strong>SIS的抗碰撞证明</strong></h3><p>若要SIS问题发生碰撞，即我们要找到两个不同的输入<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bx,+y%7D" alt="[公式]">，使得<img src="https://www.zhihu.com/equation?tex=f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D)+=+f_%5Cmathbf%7BA%7D(%5Cmathbf%7By%7D)" alt="[公式]">，即两个二进制向量<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bx,+y%7D" alt="[公式]">，并且<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BAx+=+Ay%7D+%5Ctext%7B+mod+%7Dq" alt="[公式]">，它们两个人的差有：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bz+=+x+-+y%7D+%5Cin+%5C%7B-1,+0,+1%5C%7D%5Em+%5C%5C" alt="[公式]"></p><p>因为<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bx,+y%7D" alt="[公式]">都是二进制向量，所以它们相减得到的向量，也是二进制的。（我们可以把-1和1看作是一样的，因为在距离上看是相等的。）这也就是说：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BAz+=+Ax+-+Ay+=0%7D+%5Ctext%7B+mod+%7Dq+%5C%5C" alt="[公式]"></p><p>这样一来，我们通过找到一组碰撞，我们就可以找到<img src="https://www.zhihu.com/equation?tex=%5CLambda%5E%5Cperp" alt="[公式]">这个Lattice中的一个短向量，我们就等于解决了<img src="https://www.zhihu.com/equation?tex=%5CLambda%5E%5Cperp" alt="[公式]">这个格中的SVP（或者SIVP）问题。同理，因为SVP/SIVP是困难的，所以我们不能找到SIS的碰撞啦。</p><h3 id="SIS的效率"><a href="#SIS的效率" class="headerlink" title="SIS的效率"></a>SIS的效率</h3><h4 id="SIS的参数设置"><a href="#SIS的参数设置" class="headerlink" title="SIS的参数设置"></a>SIS的参数设置</h4><p>问题：因为SIS问题的定义需要一系列的参数<img src="https://www.zhihu.com/equation?tex=m,+n,+q" alt="[公式]">，如何定义这些参数，才可以满足之前的安全性证明呢？</p><p>Ajtai在96年的paper中指出来，只要<img src="https://www.zhihu.com/equation?tex=m,+n,+q" alt="[公式]">足够大（large enough），那么<img src="https://www.zhihu.com/equation?tex=f_%5Cmathbf%7BA%7D" alt="[公式]">就是单向/collision resistant的。对于<img src="https://www.zhihu.com/equation?tex=m,+n" alt="[公式]">的值我们不去变它，因为这个决定了矩阵的维度。所以我们能做的就是压缩q的大小。</p><p>最后，在MP13中，Micciancio与Peikert把<img src="https://www.zhihu.com/equation?tex=q" alt="[公式]">的大小压到了更小。在paper中，他们指出只要<img src="https://www.zhihu.com/equation?tex=q+%5Cge+%5Csqrt%7Bn%7D" alt="[公式]">，那么Ajtai OWF就是安全的。</p><h4 id="运行效率"><a href="#运行效率" class="headerlink" title="运行效率"></a>运行效率</h4><p>验证一个SIS问题需要两部分：</p><p>1、第一部分是SIS的问题矩阵<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BA%7D" alt="[公式]">，大小由<img src="https://www.zhihu.com/equation?tex=n,+m,+q" alt="[公式]">来决定。如果在Ajtai原版的假设中，<img src="https://www.zhihu.com/equation?tex=q+=+n%5E%7BO(1)%7D,+m+=+O(n+%5Clog%7Bn%7D)+%3E+n+%5Clog_2%7Bq%7D" alt="[公式]">。在这里，我们可以假设<img src="https://www.zhihu.com/equation?tex=n+=+64,+q+=+2%5E8,+m+=+1024" alt="[公式]">。</p><p>2、第二部分就是我们的OWF输入向量<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bx%7D" alt="[公式]">，如果在二进制短向量的假设下，那么输入的就是<img src="https://www.zhihu.com/equation?tex=m" alt="[公式]">个bits。</p><p>我们观察发现<img src="https://www.zhihu.com/equation?tex=f_%5Cmathbf%7BA%7D" alt="[公式]">实质上是一个把1024 bits的输入空间（x)映射到512 bits的输出空间的一个压缩函数。（这里512由<img src="https://www.zhihu.com/equation?tex=n+%5Ctimes+%5Clog_2(q)+=+512" alt="[公式]">计算而来，因为矩阵A中的数字并不是二进制，而是1，2，3，…，q。）</p><p><img src="https://www.zhihu.com/equation?tex=f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D)+=+%5Cmathbf%7BAx%7D+%5Ctext%7B+mod+%7Dq" alt="[公式]"></p><p>在OWF的使用场景中，矩阵<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BA%7D" alt="[公式]">则是我们OWF的key，这也就是说我们的key的大小就是<img src="https://www.zhihu.com/equation?tex=nm+%5Clog%7Bq%7D+=+2%5E6+%5Ccdot+2%5E%7B10%7D+%5Ccdot+2%5E3+=+2%5E%7B19%7D+=+64+%5Ctext%7B+KB%7D" alt="[公式]">。这对于一个小的OWF来说，key的大小有点太大了。同样，如果我们计算OWF的时候，矩阵相乘需要做<img src="https://www.zhihu.com/equation?tex=nm+=+2%5E%7B16%7D" alt="[公式]">次乘法，这也是非常巨大的一个数字。我们做任何矩阵相乘运算的时候，复杂度一直都是<img src="https://www.zhihu.com/equation?tex=O(n%5E2)" alt="[公式]">的。</p><h4 id="提高效率的方法—削减密钥矩阵的大小"><a href="#提高效率的方法—削减密钥矩阵的大小" class="headerlink" title="提高效率的方法—削减密钥矩阵的大小"></a>提高效率的方法—削减密钥矩阵的大小</h4><h5 id="idea1"><a href="#idea1" class="headerlink" title="idea1"></a>idea1</h5><p>有一个很好的idea就是，如果我们并不全部随机生成整个矩阵，而是随机生成一部分，另一部分用一定的伪随机生成或者线性变换来生成，就可以大大的缩小密钥的大小了（不需要存储整个矩阵）。</p><p>基于这个idea，可以构想出一个最简单的构造：我们就只需要随机生成<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BA%7D" alt="[公式]">中的一行（甚至更短），然后把这一行作为一个PRG的种子，随机的生成整个OWF的密钥<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BA%7D" alt="[公式]">。这样的话，我们的存储成本就变得很低，但是计算成本还是一样的，甚至会因为PRG的运算变得更差。这是因为PRG生成的数值都是近似随机的，没有任何数字之间的联系。所以我们对于一个随机生成的矩阵进行运算的话，只能通过矩阵相乘，即<img src="https://www.zhihu.com/equation?tex=O(n%5E2)" alt="[公式]">的方法来完成。</p><h5 id="idea2"><a href="#idea2" class="headerlink" title="idea2"></a>idea2</h5><p>就是我们可以随机生成一个向量<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Ba%7D%5E%7B(i)%7D" alt="[公式]">，然后通过不停的旋转这一行向量的值，逐渐构成一个小的循环密钥矩阵<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BA%7D%5E%7B(i)%7D" alt="[公式]">。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Ba%7D%5E%7B(i)%7D+=+%5B%5Cmathbf%7Ba%7D_1%5E%7B(i)%7D,+%5Cmathbf%7Ba%7D_2%5E%7B(i)%7D,+%5Cdots,+%5Cmathbf%7Ba%7D_n%5E%7B(i)%7D%5D%5C%5C+%5Cmathbf%7BA%7D%5E%7B(i)%7D+=+%5Cbegin%7Bbmatrix%7D+%5Cmathbf%7Ba%7D_1%5E%7B(i)%7D+&+%5Cmathbf%7Ba%7D_n%5E%7B(i)%7D+&+%5Ccdots+&+%5Cmathbf%7Ba%7D_2%5E%7B(i)%7D%5C%5C+%5Cmathbf%7Ba%7D_2%5E%7B(i)%7D+&+%5Cmathbf%7Ba%7D_1%5E%7B(i)%7D+&+%5Ccdots+&+%5Cmathbf%7Ba%7D_3%5E%7B(i)%7D%5C%5C+%5Cvdots+&+%5Cvdots+&+%5Cddots+&+%5Cvdots%5C%5C+%5Cmathbf%7Ba%7D_n%5E%7B(i)%7D+&+%5Cmathbf%7Ba%7D_%7Bn-1%7D%5E%7B(i)%7D+&+%5Ccdots+&+%5Cmathbf%7Ba%7D_1%5E%7B(i)%7D%5C%5C+%5Cend%7Bbmatrix%7D+%5C%5C" alt="[公式]"></p><p>当我们生成这么一个循环密钥矩阵之后，我们如法炮制，一共生成<img src="https://www.zhihu.com/equation?tex=m/n" alt="[公式]">个矩阵，然后把它们横向拼接在一起，形成我们的密钥矩阵<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BA%7D" alt="[公式]">：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BA%7D+=+%5B%5Cmathbf%7BA%7D%5E%7B(1)%7D+%5Cvert+%5Cmathbf%7BA%7D%5E%7B(2)%7D+%5Cvert+%5Cdots+%5Cvert+%5Cmathbf%7BA%7D%5E%7B(m/n)%7D%5D+%5C%5C" alt="[公式]"></p><h3 id="循环矩阵到多项式"><a href="#循环矩阵到多项式" class="headerlink" title="循环矩阵到多项式"></a><strong>循环矩阵到多项式</strong></h3><p>我们可以对一个矩阵进行简化：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cwidetilde%7B%5Cmathbf%7BR%7D%7D+=%5Cbegin%7Bbmatrix%7D+1&4&3&8+%5C%5C+8&1&4&3%5C%5C+3&8&1&4%5C%5C+4&3&8&1+%5Cend%7Bbmatrix%7D+" alt="[公式]"></p><p>我们的初始生成向量为<img src="https://www.zhihu.com/equation?tex=%5B1,8,3,4%5D" alt="[公式]">，这也就是说，这个向量的第一个元素1被分配在了矩阵的正对角线上，然后后面的元素依次分配在对角线周围。我们其实可以用一个旋转矩阵<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BX%7D" alt="[公式]">来表述这一变换的过程：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BX%7D+=+%5Cbegin%7Bbmatrix%7D+0&0&0&1%5C%5C+1&0&0&0%5C%5C+0&1&0&0%5C%5C+0&0&1&0+%5Cend%7Bbmatrix%7D" alt="[公式]"></p><p>如果我们反复叠加这一旋转矩阵，就可以从1的位置旋转到8的位置，然后再旋转到3的位置，等等。这样一来，我们可以用一组线性组合来表示<img src="https://www.zhihu.com/equation?tex=%5Cwidetilde%7B%5Cmathbf%7BR%7D%7D" alt="[公式]">：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cwidetilde%7B%5Cmathbf%7BR%7D%7D+=+1+%5Ccdot+%5Cmathbf%7BI%7D+++8+%5Ccdot+%5Cmathbf%7BX%7D+++3+%5Ccdot+%5Cmathbf%7BX%7D%5E2+++4+%5Ccdot+%5Cmathbf%7BX%7D%5E3+%5C%5C" alt="[公式]"></p><p>这其实就是基于旋转矩阵<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BX%7D" alt="[公式]">的一组<img src="https://www.zhihu.com/equation?tex=n-1" alt="[公式]">阶的多项式！如果我们使用更加通用的表达方式的话，那就是：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cwidetilde%7B%5Cmathbf%7BR%7D%7D+=+a_1+I_n+++a_2X+++%5Cdots+++a_nX%5E%7Bn-1%7D+%5C%5C" alt="[公式]"></p><p>循环矩阵<img src="https://www.zhihu.com/equation?tex=%5Cwidetilde%7B%5Cmathbf%7BR%7D%7D" alt="[公式]">可以被表述成<img src="https://www.zhihu.com/equation?tex=n-1" alt="[公式]">阶多项式的形式，并且这一结构与<img src="https://www.zhihu.com/equation?tex=%5Cmathbb%7BZ%7D%5Bx%5D/(x%5En-1)" alt="[公式]">的多项式环是同构（isomorphic）的。这也就是说，我们可以使用一组最多为<img src="https://www.zhihu.com/equation?tex=n-1" alt="[公式]">阶，每一项系数在<img src="https://www.zhihu.com/equation?tex=q" alt="[公式]">以内的多项式来代替我们的循环矩阵<img src="https://www.zhihu.com/equation?tex=%5Cwidetilde%7B%5Cmathbf%7BR%7D%7D" alt="[公式]">。</p><p>我们还注意到，当旋转的次数变得过多（超出了<img src="https://www.zhihu.com/equation?tex=n-1" alt="[公式]">阶）之后，旋转到最下侧的数字会回到最上面来。这一点我们可以在这个多项式环中的乘法上定义：</p><p><img src="https://www.zhihu.com/equation?tex=x+%5Ccdot+x%5Ei+=+%5Cbegin%7Bcases%7D+x%5E%7Bi+1%7D+&+i+%3C+n-1+%5C%5C+1+&+i+=+n-1+%5Cend%7Bcases%7D" alt="[公式]"></p><p>因为我们在<img src="https://www.zhihu.com/equation?tex=x%5En+-1" alt="[公式]">的环中，<img src="https://www.zhihu.com/equation?tex=x%5En" alt="[公式]">比我们的环的大小<img src="https://www.zhihu.com/equation?tex=x%5En-1" alt="[公式]">要大1，所以说<img src="https://www.zhihu.com/equation?tex=x%5En+=+1+%5Ctext%7B+mod+%7D+(x%5En+-+1)" alt="[公式]">。</p><p>当我们把<img src="https://www.zhihu.com/equation?tex=%5Cwidetilde%7B%5Cmathbf%7BR%7D%7D" alt="[公式]">用多项式表达之后，我们就会发现，<img src="https://www.zhihu.com/equation?tex=x%5En+-+1" alt="[公式]">这一多项式，其实是很好约分的：</p><p><img src="https://www.zhihu.com/equation?tex=x%5En+-+1+=+(x-1)+%5Ccdot+(x%5E%7Bn-1%7D+++%5Cdots+++1)" alt="[公式]"></p><p>这就是为什么我们可以非常简单的找到SIS的解，因为我们可以很简单的找到这个多项式环中的0交界点。</p><h3 id="多项式到RingSIS"><a href="#多项式到RingSIS" class="headerlink" title="多项式到RingSIS"></a><strong>多项式到RingSIS</strong></h3><p>因为我们发现循环矩阵<img src="https://www.zhihu.com/equation?tex=%5Cwidetilde%7B%5Cmathbf%7BR%7D%7D" alt="[公式]">可以很好的被多项式环代替，我们索性就把原本的SIS OWF的key矩阵变成<img src="https://www.zhihu.com/equation?tex=k+=+m+/+n" alt="[公式]">个多项式拼接在一起。同理，我们把OWF的输入矩阵也变成<img src="https://www.zhihu.com/equation?tex=k" alt="[公式]">个多项式：</p><p><img src="https://www.zhihu.com/equation?tex=f_%7B%5Cmathbf%7Ba%7D_1,+%5Cdots,+%5Cmathbf%7Ba%7D_k%7D(%5Cmathbf%7Bu%7D_1,+%5Cdots,+%5Cmathbf%7Bu%7D_k)+=+%5Csum_i+%5Cmathbf%7Ba%7D_i(X)+%5Ccdot+%5Cmathbf%7Bu%7D_i(X)+%5Ctext%7B+mod+%7D+(X%5En+-+1)%5C%5C+%5Cmathbf%7Ba%7D_i,+%5Cmathbf%7Bu%7D_i+%5Cin+R+=+%5Cmathbb%7BZ%7D%5BX%5D/(X%5En+-+1)" alt="[公式]"></p><p>这样以来，我们就可以通过多项式相乘的方法来计算原本的循环矩阵版的SIS OWF了。随后得到的值也会是一样的，因为我们可以代入原本的旋转矩阵<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BX%7D" alt="[公式]">为这里多项式中的取值X，然后等式全部成立。</p><p>我们把这样的，通过多项式环中相乘（而不是矩阵相乘）的类似SIS问题，称之为RingSIS。</p><p>好处：</p><p>1、与之前的循环矩阵的优势一样，我们只需要存储一组随机的向量（即多项式的参数赋值），就可以定义整个问题，这样的存储成本就很低。</p><p>2、多项式之间相乘可以通过FFT（快速傅立叶变换）来达到<img src="https://www.zhihu.com/equation?tex=%5Ctilde%7BO%7D(n)" alt="[公式]">的效率。比起矩阵相乘<img src="https://www.zhihu.com/equation?tex=O(n%5E2)" alt="[公式]">的效率来说，是质一般的飞跃。</p><h3 id="加强安全性的RingSIS"><a href="#加强安全性的RingSIS" class="headerlink" title="加强安全性的RingSIS"></a>加强安全性的RingSIS</h3><p>在RingSIS中，我们可以任意选择想要的多项式环。因为我们之前发现了<img src="https://www.zhihu.com/equation?tex=X%5En+-+1" alt="[公式]">这个环很好约分，所以对应的OWF容易被找到collision，所以我们可以考虑，换一个更加安全的环。</p><p>为了通俗的表达各种多项式环，我们一般都把RingSIS问题中的环用<img src="https://www.zhihu.com/equation?tex=%5Cmathbb%7BZ%7D%5BX%5D/p(X)" alt="[公式]">来表示，其中<img src="https://www.zhihu.com/equation?tex=p(X)" alt="[公式]">就是任意一个monic polynomial。</p><p>如果<img src="https://www.zhihu.com/equation?tex=p(X)" alt="[公式]">不能被进一步约分，那么我们就不能用同样的方法来更快速的找到collision。这样的话我们就可以把不能约分的多项式环下的RingSIS问题的难度规约到理想格（ideal lattice）中的SVP问题上来了。</p><p>一个比较简单的例子就是<img src="https://www.zhihu.com/equation?tex=%5Cmathbb%7BZ%7D%5BX%5D/(X%5En+++1)" alt="[公式]">。这个环和之前的环一样，也包括了所有的<img src="https://www.zhihu.com/equation?tex=n-1" alt="[公式]">阶的多项式。唯一不一样的，是乘法的定义：</p><p><img src="https://www.zhihu.com/equation?tex=x+%5Ccdot+x%5Ei+=+%5Cbegin%7Bcases%7D+x%5E%7Bi+1%7D+&+i+%3C+n-1%5C%5C+-1+&+i+=+n-1+%5Cend%7Bcases%7D" alt="[公式]"></p><p>在得到临界值<img src="https://www.zhihu.com/equation?tex=x%5En" alt="[公式]">的时候，因为我们的环的大小就是<img src="https://www.zhihu.com/equation?tex=x%5En+++1" alt="[公式]">，比<img src="https://www.zhihu.com/equation?tex=x%5En" alt="[公式]">大1，所以我们可以用-1来表示。这样一来，和之前一样是一个Ring的结构，只是乘法的定义有所改变。</p><p>在这种方式下，对应的循环矩阵<img src="https://www.zhihu.com/equation?tex=%5Cwidetilde%7B%5Cmathbf%7BR%7D%7D" alt="[公式]">就是：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cwidetilde%7B%5Cmathbf%7BR%7D%7D+=+%5Cbegin%7Bbmatrix%7D+1&-4&-3&-8%5C%5C+8&1&-4&-3%5C%5C+3&8&1&-4%5C%5C+4&3&8&1+%5Cend%7Bbmatrix%7D%5C%5C" alt="[公式]"></p><h2 id="SIS的应用"><a href="#SIS的应用" class="headerlink" title="SIS的应用"></a>SIS的应用</h2><h3 id="1、压缩属性的应用"><a href="#1、压缩属性的应用" class="headerlink" title="1、压缩属性的应用"></a>1、压缩属性的应用</h3><p>我们原来有<img src="https://www.zhihu.com/equation?tex=m" alt="[公式]"> bits的信息量，我们等于是把它压缩到了<img src="https://www.zhihu.com/equation?tex=n" alt="[公式]">个<img src="https://www.zhihu.com/equation?tex=q" alt="[公式]">模中的数字，即<img src="https://www.zhihu.com/equation?tex=n+%5Clog%7Bq%7D" alt="[公式]">个bits的信息量。这也正好符合了SIS OWF满射（surjective）的特性，输入空间比输出空间大得多。</p><p>基于这一压缩的特性，我们很自然的就可以用SIS OWF来做一个Collision Resistant Hash Function。具体的CR和单向性我们之前也讨论过了。</p><h3 id="2、SIS的输出随机分布与承诺"><a href="#2、SIS的输出随机分布与承诺" class="headerlink" title="2、SIS的输出随机分布与承诺"></a>2、SIS的输出随机分布与承诺</h3><p>LHL指出，如果一个函数具有Pairwise Independence，并且输出空间小于输入空间（压缩），那么这个函数的输出就为随机分布。</p><p>首先来看Pairwise Independence这一点，它的定义就是，如果任意固定两个输入<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bx%7D_1,+%5Cmathbf%7Bx%7D_2" alt="[公式]">，然后我们随机选择一个SIS问题<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BA%7D" alt="[公式]">，如果<img src="https://www.zhihu.com/equation?tex=f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D_1),+f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D_2)" alt="[公式]">这两个SIS OWF的输出分布是独立的，那么这就代表这个函数是成对独立的（Pairwise Independent）。</p><p>当满足随机分布的条件之后，那么我们就可以把<img src="https://www.zhihu.com/equation?tex=f_%5Cmathbf%7BA%7D" alt="[公式]">的输出看做一个随机分布的向量：</p><p><img src="https://www.zhihu.com/equation?tex=f_%5Cmathbf%7BA%7D+%5Capprox+U(%5Cmathbb%7BZ%7D_q%5En)+%5C%5C" alt="[公式]"></p><p>基于这一特性，我们就可以构建一个承诺（Commitment）系统。一方可以生成一段信息<img src="https://www.zhihu.com/equation?tex=m" alt="[公式]">的承诺<img src="https://www.zhihu.com/equation?tex=C" alt="[公式]">，然后把这个承诺发送给另一方。承诺的本身并不能暴露<img src="https://www.zhihu.com/equation?tex=m" alt="[公式]">的值，即需要满足hiding的属性。稍后，承诺方可以公布一段字串来“打开”这个承诺，随后另一方就可以验证这个承诺的确是从信息<img src="https://www.zhihu.com/equation?tex=m" alt="[公式]">构造而来的。一个承诺打开的方法应该只能有一种，即需要满足binding的属性。</p><p>密码学承诺方案是一个涉及两方的二阶段交互协议，双方分别为承诺方和接收方。第一阶段为承诺级阶段，承诺方选择一个消息m，以密文的形式发送给接收方，意味着自己不会更改m。第二阶段为打开阶段，承诺方公开消息m与盲化因子（相当于秘钥），接收方以此来验证其与承诺阶段所接收的消息是否一致。</p><p>我们基于SIS OWF来尝试构建一个承诺系统：</p><ol><li><p>首先，我们选择两个随机的SIS问题矩阵<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BA%7D_1,+%5Cmathbf%7BA%7D_2" alt="[公式]">。</p></li><li><p>假如我们要承诺信息<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bm%7D+%5Cin+%5C%7B0,1%5C%7D%5Em" alt="[公式]">，那我们随机选择一个向量<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Br%7D+%5Cin+%5C%7B0,1%5C%7D%5Em" alt="[公式]">，然后我们输出承诺<img src="https://www.zhihu.com/equation?tex=C(%5Cmathbf%7Bm,+r%7D)+=+f_%7B%5B%5Cmathbf%7BA%7D_1,+%5Cmathbf%7BA%7D_2%5D%7D(%5Cmathbf%7Bm,+r%7D)+=+%5Cmathbf%7BA%7D_1+%5Cmathbf%7Bm%7D+++%5Cmathbf%7BA%7D_2+%5Cmathbf%7Br%7D" alt="[公式]">。</p></li><li><p>注意到这里因为<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BA%7D_2,+%5Cmathbf%7Br%7D" alt="[公式]">都是随机生成的，所以基于SIS OWF的随机分布特性，这等于是在我们原本的<img src="https://www.zhihu.com/equation?tex=f_%7B%5Cmathbf%7BA%7D_1%7D(%5Cmathbf%7Bm%7D)" alt="[公式]">上叠加了一层随机的One-Time Pad，所以整体承诺也是随机分布的。</p></li><li><p>同样，这个承诺也是binding的，因为如果我们能够找到一对不同的<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bm%27,+r%27%7D" alt="[公式]">并且可以得到同样的承诺的话，那就等于是我们找到了<img src="https://www.zhihu.com/equation?tex=f_%7B%5B%5Cmathbf%7BA%7D_1,+%5Cmathbf%7BA%7D_2%5D%7D" alt="[公式]">的一对碰撞，这我们已经证明了是不可能的。</p><h3 id="3、SIS的线性同态特性与数字签名"><a href="#3、SIS的线性同态特性与数字签名" class="headerlink" title="3、SIS的线性同态特性与数字签名"></a>3、SIS的线性同态特性与数字签名</h3><p>因为SIS OWF其实就是一个线性组合的表达式，所以整个function其实是线性同态的：</p><p><img src="https://www.zhihu.com/equation?tex=f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D_1)+++f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D_2)+=+f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D_1+++%5Cmathbf%7Bx%7D_2)+%5C%5C" alt="[公式]"></p></li></ol><p>这里有一点不太完美的地方，即<img src="https://www.zhihu.com/equation?tex=f_%5Cmathbf%7BA%7D" alt="[公式]">需要一个norm比较小的输入。然而如果我们把两个短向量相加，得到的并不一定是短向量。这也就是说，这里的加法运算并不是封闭的。</p><p>SIS OWF其实还包含了另一组同态，即密钥同态：</p><p><img src="https://www.zhihu.com/equation?tex=f_%7B%5Cmathbf%7BA%7D_1%7D(%5Cmathbf%7Bx%7D)+++f_%7B%5Cmathbf%7BA%7D_2%7D(%5Cmathbf%7Bx%7D)+=+f_%7B%5Cmathbf%7BA%7D_1+++%5Cmathbf%7BA%7D_2%7D(%5Cmathbf%7Bx%7D)+" alt="[公式]"></p><p>基于第一种输入空间同态的特性，我们可以构造出一个数字签名系统。一个签名系统一般分为三个算法：</p><ol><li><img src="https://www.zhihu.com/equation?tex=KeyGen+%5Crightarrow+(sk,+pk)" alt="[公式]">，即密钥生成，生成用于签名和验证的私钥与公钥。</li><li><img src="https://www.zhihu.com/equation?tex=Sign(sk,+m)+%5Crightarrow+%5Csigma" alt="[公式]">，签名算法，通过私钥创造出签名。</li><li><img src="https://www.zhihu.com/equation?tex=Verify(pk,+m,+%5Csigma)+%5Crightarrow+1/0" alt="[公式]">，验证算法，通过公钥来验证签名是否正确。</li></ol><p>为了构建这一系统，首先需要把SIS OWF的输入空间从一个向量<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bx%7D" alt="[公式]">拓展成一个矩阵<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BX%7D" alt="[公式]">：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BX%7D+=+%5B%5Cmathbf%7Bx%7D_1,+%5Cdots,+%5Cmathbf%7Bx%7D_l%5D%5C%5C+f_%5Cmathbf%7BA%7D(%5Cmathbf%7BX%7D)+=+%5Bf_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D_1),+%5Cdots,+f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D_l)%5D+=+%5Cmathbf%7BAX%7D+%5Ctext%7B+mod+%7Dq" alt="[公式]"></p><p>在密钥生成阶段，我们只需要随机生成SIS的问题矩阵<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BA%7D" alt="[公式]">并输出。然后我们选定一个随机的短矩阵和短向量<img src="https://www.zhihu.com/equation?tex=(%5Cmathbf%7BX,+x%7D)" alt="[公式]">作为私钥，并且选定<img src="https://www.zhihu.com/equation?tex=(%5Cmathbf%7BY%7D+=+f_%5Cmathbf%7BA%7D(%5Cmathbf%7BX%7D),+%5Cmathbf%7By%7D+=+f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D))" alt="[公式]">，即私钥在SIS OWF下运算得到的结果作为公钥。</p><p>如果要签署一个消息<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bm%7D" alt="[公式]">的话，那么就计算<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BXm+++x%7D" alt="[公式]">，并且输出为签名。</p><p>随后验证的过程也很简单，只需要计算：</p><p><img src="https://www.zhihu.com/equation?tex=f_%5Cmathbf%7BA%7D(%5Csigma)+=+f_%5Cmathbf%7BA%7D(%5Cmathbf%7BXm+++x%7D)+=+f_%5Cmathbf%7BA%7D(%5Cmathbf%7BX%7D)%5Cmathbf%7Bm%7D+++f_%5Cmathbf%7BA%7D(%5Cmathbf%7Bx%7D)+%5Cstackrel%7B?%7D%7B=%7D+%5Cmathbf%7BYm+++y%7D" alt="[公式]"></p><p>这里SIS OWF的同态特性就很完美的帮助我们验证了这一签名的正确性。至于安全性的话，一方面单独只看到一个<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BXm+++x%7D" alt="[公式]">是无法推算出<img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BX,+x%7D" alt="[公式]">的值的，所以这个签名是One-Time Secure（单次安全）的啦。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生是场马拉松，不是百米跑</title>
      <link href="2021/04/05/ren-sheng-shi-chang-ma-la-song-bu-shi-bai-mi-pao/"/>
      <url>2021/04/05/ren-sheng-shi-chang-ma-la-song-bu-shi-bai-mi-pao/</url>
      
        <content type="html"><![CDATA[<p>小时候，我曾经因为爸妈多给了哥哥几块钱，就故意赌气假装走丢，其实我是走了另一条路回家，当时的我就觉得，爸爸妈妈根本就不爱我，他们太偏心了。现在回忆起来，当时我回去的时候他们一直在焦急的在寻找我，哪有什么偏不偏心，一切都是自己在自寻烦恼。</p><p>高中时，因为一次考试失利，可能就难受的好几天吃不下饭，甚至陷入自我怀疑的情绪之中；现在看来，考试成绩本就是起起伏伏，一时的失利根本代表不了什么，它只能表示你有些知识点还没有掌握，根本没必要难受。</p><p>大学时，因为一次失恋，整个人几个月都走不出去。好吧，现在也不能说已经完全走出来，但从现在的自己看刚失恋时自己做的一些事已经觉得很可笑了。</p><p>生活中不如意的事每天都在上演，那为什么同一件事情在两个时间点的我们看来有这么大的不同呢。我认为，当我们身处局中，我们看待事物就把它当成了自己生活中的很大一部分。但当我们回首往事时，某一件事情只是我们度过的漫长的人生中的一件事，它并不会占据我们多大的人生，所以不值一提。</p><p>那我们应该怎样好好的过完这一生？对待开心的事，我们就要身处局中，好好的去享受生活的乐趣；对待糟糕的事，我们就应该将自己置身于整个人生中思考，将其摒弃掉。</p><p>对待开心的事情就是想办法让它留的更久。从今年开始，我开始喜欢出去玩，去认识一些新的人与事物，并且迫切的想将它们记录下来。因为我知道，在宿舍玩一局游戏、睡一下午、看一本网络小说，它只能让你快乐一下，它们在你的人生中掀不起一丝浪花；但是我去一次动物园、看一次樱花、体验一次蹦极，用文字和照片记录下来，那么就算过了一二十年，回忆起来，这些事情依旧能让你回味无穷。</p><p>对待糟糕的事情就是想办法让自己置身于整个人生去面对它。生活中或多或少会有一些“小人”，她们会做一些让你难受的事，对待这种的人最好的方式就是远离她。因为远离了她们，她们就只是你人生中短暂的一个过客，不值得你去因为她难受。除了恶心的人，还会有一些糟糕的事情会发生在你身上，但是再糟糕能糟糕到哪去。于我而言，只要家人朋友自己身体健康，无病无灾，其他的都算不了什么，因为除了健康没有什么是不能再去通过努力重新获得的。</p><p>人生是场马拉松，不是百米跑。我们要把自己的情绪调整好，开心过一天，不开心也是过一天，让所有的烦恼都像风一样飘散，让所有的开心都像阳光一样照遍自己的生活！</p><p><img src="/image/%E4%BA%BA%E7%94%9F%E6%98%AF%E5%9C%BA%E9%A9%AC%E6%8B%89%E6%9D%BE%EF%BC%8C%E4%B8%8D%E6%98%AF%E7%99%BE%E7%B1%B3%E8%B7%91/smile.jpg" alt="smile"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的博客创建之旅</title>
      <link href="2021/04/04/wo-de-bo-ke-chuang-jian-zhi-lu/"/>
      <url>2021/04/04/wo-de-bo-ke-chuang-jian-zhi-lu/</url>
      
        <content type="html"><![CDATA[<p>​        大概是在一个星期之前，我的心中突然萌发了想要创建一个自己博客的想法。因为我觉得学习的过程是一个不断反思提高的过程，而博客正好可以当作一处记录的平台。不仅如此，有的时候心中也有一些对于生活的思考感悟，这些都可以放在博客上，宛如创造了一个互联网上的“我的世界”。经过一个星期的摸爬滚打，博客也算有了一个初步的雏形，因此想把这个过程记录下来。</p><h2 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h2><p>​        首先，你要确定自己到底想要搭建一个什么样的博客；如果是依托于CSDN、博客园等平台，那么简单的去注册账号即可。但我当时觉得创建一个个人博客网站，不是更有“小天地”的感觉吗。于是，在大量的网上查询的过程中，确定了基于Hexo搭建博客的想法。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>​        在搭建博客初期，心中的想法是部署到云服务器上，并且用一个域名去指向它。于是，在最开始，我在<a href="https://wanwang.aliyun.com/">阿里云</a>平台上购买了一个域名，新人优惠很便宜，我当时就只花了8.8元就购买了一年。然后就是云服务器的事情，大学生可以通过学生认证<a href="https://developer.aliyun.com/adc/student/?spm=a2c6h.19776329.J_8005678510.6.564b3d80CBIvEi#J_5144437010">免费获得</a>两个月的免费使用时间，后续还可以通过答题再次获得一段免费时间。</p><h2 id="云服务器上的部署"><a href="#云服务器上的部署" class="headerlink" title="云服务器上的部署"></a>云服务器上的部署</h2><p>​        在最开始，我的想法是照着网上的一篇教程做下来，我也找到了一篇<a href="https://blog.objectspace.cn/2019/08/15/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%A5%B6%E5%A6%88%E7%BA%A7%E6%95%99%E5%AD%A6/#">很好的教程</a>。但由于自己对于教程中的一些步骤“知其然，而不知其所以然”，所以在最后的部署过程一直报错。不过我也很感谢这次失败，正是因为这些失败，我才不断的去网上找相应的失败原因和解决方法，最后对于搭建博客有了更深的认识。下面的一些步骤是我自己根据教程总结出来的，当然，大部分还是和教程一样的，不过我加入了一些自己对于步骤的想法。</p><h3 id="推倒重来"><a href="#推倒重来" class="headerlink" title="推倒重来"></a>推倒重来</h3><p>​        如果你是第一次开始创建，那这个可以略过不看。如果你也是因为后面的一次次部署失败而想重头再来，那可以参考一下。</p><p>​        云服务器的初始化很简单：</p><p>​        首先进入控制台中的ECS服务器管理，然后将实例停止：</p><p><img src="/image/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E4%B9%8B%E6%97%85/0.png" alt="0"></p><p>​        然后初始化云盘：</p><p><img src="/image/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E4%B9%8B%E6%97%85/1.png" alt="1"></p><p>​        这样，就回到了最初的状态。</p><h3 id="服务器初始设置"><a href="#服务器初始设置" class="headerlink" title="服务器初始设置"></a>服务器初始设置</h3><p>首先重新设置云服务器的密码：</p><p><img src="/image/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E4%B9%8B%E6%97%85/2.png" alt="2"></p><p>设置完成以后就可以在主机上远程登陆服务器了。</p><p>在登陆之前先配置好安全组规则，允许80端口的访问：</p><p><img src="/image/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E4%B9%8B%E6%97%85/3.png" alt="3"></p><p><img src="/image/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E4%B9%8B%E6%97%85/4.png" alt="4"></p><p>第一次访问云服务器建议使用putty软件：</p><p><img src="/image/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E4%B9%8B%E6%97%85/5.png" alt="5"></p><p>然后输入：root，回车以后再输入密码就登陆到云服务器了。</p><h3 id="配置云服务器"><a href="#配置云服务器" class="headerlink" title="配置云服务器"></a>配置云服务器</h3><p>我们需要nginx作为我们的网站服务器，所以我们首先要安装nginx，我们可以使用yum命令直接进行安装。</p><h4 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h4><p>安装的执行命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure><p>然后启动服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure><p>在这里我们要记住/etc/nginx/是nginx默认的配置路径，一会要用到。</p><p>在我们启动之前是云服务器的公网地址是无法访问的，启动之后就会出现如下页面：</p><p><img src="/image/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E4%B9%8B%E6%97%85/6.png" alt="6"></p><p>但是我们实际上是想要让这个公网地址指向我们的博客，而不是nginx的默认网址，这就需要我们去配置nginx的配置文件。阿里云默认的库下载的是fedora版本的nginx，所以我们应该配置的是位于 etc/nginx/ 下的 nginx.conf 。</p><p>我们可以打开该文件并修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><p>修改前：</p><p><img src="/image/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E4%B9%8B%E6%97%85/7.png" alt="7"></p><p>修改后：</p><p><img src="/image/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E4%B9%8B%E6%97%85/8.png" alt="8"></p><p>按esc退出编辑，:wq保存退出。</p><p>因为我们在配置中指明了将/home/www/website作为博客目录存放地址，因此此时我们需要去创建它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;home</span><br><span class="line">mkdir www</span><br><span class="line">cd www</span><br><span class="line">mkdir website</span><br></pre></td></tr></table></figure><h4 id="云服务器中安装Git以及Node-js"><a href="#云服务器中安装Git以及Node-js" class="headerlink" title="云服务器中安装Git以及Node.js"></a>云服务器中安装Git以及Node.js</h4><h5 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_10.x | bash -</span><br><span class="line">sudo yum install -y nodejs</span><br></pre></td></tr></table></figure><p>有如下显示则表示安装成功：</p><p><img src="/image/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E4%B9%8B%E6%97%85/9.png" alt="9"></p><h5 id="安装Git及配置仓库"><a href="#安装Git及配置仓库" class="headerlink" title="安装Git及配置仓库"></a>安装Git及配置仓库</h5><p>这一部分的主要目的是让我们个人的电脑可以通过ssh方式连接到云服务器，然后我们就可以通过命令行方式将我们的博客Po到服务器上。操作如下：</p><h5 id="安装git"><a href="#安装git" class="headerlink" title="安装git:"></a>安装git:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><h5 id="配置git用户："><a href="#配置git用户：" class="headerlink" title="配置git用户："></a>配置git用户：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser git</span><br></pre></td></tr></table></figure><p>修改用户权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 740 &#x2F;etc&#x2F;sudoers</span><br><span class="line">vi &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure><p>注意文件夹中权限设置的意义：</p><p><img src="/image/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E4%B9%8B%E6%97%85/10.png" alt="10"></p><p>然后在这个地方添加这句话：</p><p><img src="/image/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E4%B9%8B%E6%97%85/11.png" alt="11"></p><p>这样，服务器的用户就有了root和git两个（这里很重要，你在不同的用户下面进行同样的操作，最后会产生不同的结果，我的第一次失败很大原因就是因为这个。）</p><p>保存退出后 将sudoers文件权限改回原样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure><p>设置git用户的密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd git</span><br></pre></td></tr></table></figure><p>注意：后面的ssh公钥，既标识用户，也标识机器，所以在使用的时候要注意切换。</p><h4 id="云服务器中的公钥配置"><a href="#云服务器中的公钥配置" class="headerlink" title="云服务器中的公钥配置"></a>云服务器中的公钥配置</h4><p>首先切换到git用户，然后在~目录下创建.ssh文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su git</span><br><span class="line">cd ~</span><br><span class="line">mkdir .ssh</span><br><span class="line">cd .ssh</span><br></pre></td></tr></table></figure><p>生成公钥密钥文件(接下来这几步都在主机里面做，使用gitbash)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>此时在目录下就会有两个文件，分别是</p><p>id_rsa 和 id_rsa.pub</p><p>其中 id_rsa.pub 就是公钥文件 我们打开文件并复制一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim id_rsa.pub</span><br></pre></td></tr></table></figure><p>接下来，接着回到服务器中进行操作：</p><p>在服务器中生成认证文件authorized_keys：（在git用户下的.ssh文件夹中哦）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch authorized_keys</span><br><span class="line">vim authorized_keys</span><br></pre></td></tr></table></figure><p>然后将我们刚才从id_rsa.pub中复制的密钥粘贴进去</p><p>最后我们修改它的权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 ~&#x2F;.ssh&#x2F;authorized_keys</span><br><span class="line">chmod 700 ~&#x2F;.ssh</span><br></pre></td></tr></table></figure><p>这个时候，我们就可以在主机，打开cmd或gitbash，使用ssh方式连接我们的云服务器了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh git@服务器公网IP</span><br></pre></td></tr></table></figure><h4 id="在云服务器中创建git仓库"><a href="#在云服务器中创建git仓库" class="headerlink" title="在云服务器中创建git仓库"></a>在云服务器中创建git仓库</h4><p>现在我们要开始创建一个git的仓库，并且新建一个post-receive文件，目的是为了接收来自主机的git操作，操作如下:（注意，这些操作都处于git用户之下的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">git init --bare blog.git</span><br><span class="line">vi ~&#x2F;blog.git&#x2F;hooks&#x2F;post-receive</span><br></pre></td></tr></table></figure><p>然后在post-receive文件中输入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --work-tree&#x3D;&#x2F;home&#x2F;www&#x2F;website --git-dir&#x3D;&#x2F;home&#x2F;git&#x2F;blog.git checkout -f</span><br></pre></td></tr></table></figure><p>这样就把git仓库中的文件指向/home/www/website了。</p><p>保存退出并授予该文件可执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ~&#x2F;blog.git&#x2F;hooks&#x2F;post-receive</span><br></pre></td></tr></table></figure><p>至此我们就完成了所有关于服务器端的所有配置。</p><h2 id="在Windows主机上的配置"><a href="#在Windows主机上的配置" class="headerlink" title="在Windows主机上的配置"></a>在Windows主机上的配置</h2><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><p>在主机上的操作比较简单，首先先在主机上安装好git，然后确保安装好了node.js。</p><p>如果显示以下内容则代表已经安装好：</p><p><img src="/image/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E4%B9%8B%E6%97%85/12.png" alt="12"></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装<a href="https://hexo.io/zh-cn/docs/">Hexo</a></h3><p>在安装之前，将npm换成淘宝的服务器，避免因为连到国外的服务器而导致卡顿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>接下来就直接安装 hexo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h3><p>然后我们选择一个目录用来初始化博客程序，例如F:/Blog</p><p>在cmd中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F:</span><br><span class="line">cd blog</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>执行成功后再安装两个插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-server</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>之后我们就可以在自己的本机上，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a>查看自己的博客了；</p><p>修改blog文件夹中的配置文件<a href="https://blog.csdn.net/zemprogram/article/details/104288872">_config.yml</a>完成博客的部署，这个步骤的目的是将我们的博客指向我们的服务器中。</p><p>在刚才生成Hexo的目录下，找到_config.yml，打开它。</p><p>找到deploy 做如下配置（注意冒号后面有空格,type,repo,branch,message前面也加两个空格）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@这里改为服务器公网IP:&#x2F;home&#x2F;git&#x2F;blog.git       </span><br><span class="line">  branch: master                           </span><br><span class="line">  message:</span><br></pre></td></tr></table></figure><p>保存退出，然后尝试写一篇文章并且发布到服务器上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;Hello My First Blog&quot;</span><br><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>在服务器上重新运行nginx服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>这样，就将博客部署到服务器上了，可通过公网IP进行访问了。</p><h2 id="出现的错误："><a href="#出现的错误：" class="headerlink" title="出现的错误："></a>出现的错误：</h2><p>通过以上的步骤应该可以通过公网IP访问到自己的博客了，但我在部署后出现了如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote: fatal: cannot create directory at &#39;2021&#39;: Permission denied</span><br></pre></td></tr></table></figure><p>并且部署目录/home/www/website/里面并没有推送的文件，出现这个问题的原因应该是部署目录/home/www/website/ 没有写权限导致的。</p><p>解决方法：添加写权限只能就可以了。(注意：在root权限下方可执行)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;www</span><br><span class="line">chmod go+w website</span><br></pre></td></tr></table></figure><h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><p>在将前面的步骤完成之后，现在该做的就是选择一个漂亮的主题了，主题可以在<a href="https://hexo.io/themes/">Hexo主题网站</a>中进行选择。在你选择好主题后会进入到该主题对应的GitHub项目中，访问项目中的Wiki即可获得安装步骤。</p><p>说来惭愧，在最开始的时候我选择了<a href="https://github.com/tomotoes/hexo-theme-tomotoes">hexo-theme-tomotoes</a>，但在安装主题的过程中一直出错，最后只能选择放弃。我选择的第二个主题是<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>，这个主题在作者的<a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">博客</a>中有详细的介绍，因此不再加以赘述。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>在前面的步骤完成之后，现在我能利用云服务器的公网IP对博客进行访问了，但我想要的是利用域名进行访问。如果需要用域名解析到国内的服务器并进行访问需要对域名和服务器进行备案，这里又出现一个难题，服务器备案需要购买超过三个月，而我领到的免费云服务器只有两个月。不仅如此，如果一直使用云服务器，后续的开销也会越来越大，这对于仅仅是学生的我负担很大。因此开始考虑优化博客的部署方案。</p><p>优化考虑的方案是将博客部署到Github上，在最开始之所以没有考虑GitHub的原因是Github访问太慢，而且有时候会出现连接断开的问题。在经过搜索之后，我发现了可以利用Vercel解决这个问题。</p><h4 id="Github部署博客"><a href="#Github部署博客" class="headerlink" title="Github部署博客"></a><a href="https://blog.csdn.net/princek123/article/details/84067942?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=1328767.43301.16175234863539657&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">Github部署博客</a></h4><p>这里需要注意的是blog中_config.yml的修改，注意修改两个地方，一个是deploy，还有一个是url和root：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:xxx&#x2F;xxx.github.io.git       </span><br><span class="line">  branch: master                           </span><br><span class="line">  message:</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url: https://xxx.github.io/</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure><p>特别注意：GitHub上并不是实时更新的，它会有一段时间的延迟，因此如果修改了以后一下子没有刷新出来不妨等一会儿。</p><h3 id="Vercel上部署Github的项目"><a href="#Vercel上部署Github的项目" class="headerlink" title="Vercel上部署Github的项目"></a><a href="https://blog.csdn.net/wzc_coder/article/details/112300956">Vercel上部署Github的项目</a></h3><p>这里注意的是域名的解析，不妨在控制台中将xxx.com和”www+xxx.com”都进行解析，这样，这两个网址都会指向Vercel中的项目。</p><h2 id="博客编辑器"><a href="#博客编辑器" class="headerlink" title="博客编辑器"></a>博客编辑器</h2><p>在这里我推荐两个博客编辑器，一个是<a href="https://github.com/zhuzhuyule/HexoEditor">HexoEditor</a>,一个是<a href="https://typora.io/">typora</a>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上只是将一个博客的台子给搭好了，后面还有更多的内容需要自己去慢慢摸索。</p><p>（以上内容是作者本人的一些经历感悟，如果有问题欢迎讨论交流！）</p>]]></content>
      
      
      <categories>
          
          <category> 博客创建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客创建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
